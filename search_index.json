[
["index.html", "Introdução ao R/R Studio Prefácio Estrutura do livro Soluções ocultas", " Introdução ao R/R Studio Eduardo F. Silva 2017-10-30 Prefácio Esse site complementa o Curso de Introdução ao R/RStudio. Esse é um material ainda em construção. Todas as sugestões e correções são bem vindas e podem enviadas para e{ponto}f{ponto}Silva{em}ufsc{ponto}br Estrutura do livro Os comandos em R serão apresentados blocos com o exemplo abaixo: x &lt;- 1:10 x Soluções ocultas Alguns comando em R, geralmente relacionados à algum exercício, poderão ter sua apresentação oculta. Bastando pressionar o botão solução para que a mesma seja apresentada. Solução 1 + 1 ## [1] 2 "],
["sobre-o-autor.html", "Sobre o Autor", " Sobre o Autor Eduardo F. Silva Professor Departamento de Engenharia de Produção e Sistemas Universidade Federal de Santa Catarina e{.}f{.}Silva{em}ufsc{.}br "],
["Introdução.html", "Unidade 1 Introdução ao R 1.1 Instalação e Configuração 1.2 Um pouco de história 1.3 Sua primeira sessão em R 1.4 Iniciando um projeto 1.5 Entendendo os pacotes em R", " Unidade 1 Introdução ao R R é um software livre (open-source) que disponibiliza todo um ambiente computacional para a realização de análises estatísticas (colaborativas e reprodutíveis), incluindo a produção de gráficos de alta qualidade, facilmente customízavéis. Esse ambiente pode ser compilado e executado em diferentes plataformas(UNIX, Windows e MacOS). 1.1 Instalação e Configuração **ATENÇÃO: Pule essa seção se não está usando R localmente. (Por exemplo, usando R via servidor Jupyter no browser.) Se vc ainda não instalou os programas: Download e instale R ( http://cran.r-project.org ) Download e instale RStudio ( https://www.rstudio.com ). Oferece uma interface amigavel para interação com o ambiente R, facilitando e estendendo o uso das suas funcionalidades. 1.2 Um pouco de história A linguagem S foi uma linguagem de programação para análises estatísticas desenvolvida por John Chambers e colegas no laboratório da Bell/AT&amp;T. Após a definição da linguagem de formal, uma implementação comercial foi desenvolvida e comercializada com o nome de S-Plus. (2001) Usei esse pacote comercial S-Plus, e foi meu primeiro contato com o que viria a ser o R :) O S-Plus implementava uma interface gráfica mais amigável para a utilização da linguagem “S”. Mesma ideia do RStudio A partir da definição formal da linguagem S, o código foi então reaproveitado por dois acadêmicos autralianos, Ross Ihaka e Robert Gentleman, resultando na plataforma de programação R que temos hoje. Dizem que o nome dessa linguagem foi escolhido devido a primeira letra do primeiro nome de seus criadores. Prefiro acreditar que se segue ao S (do pacote inicial.) O R Studio é só mais uma interface para o ambiente R, mas que conquistou uma grande fatia de mercado pela forma como disponibiliza e estende as funcionalidades do ambiente R. 1.3 Sua primeira sessão em R Esse é o R! Figura 1.1: Janela do R E aqui o R Studio Figura 1.2: Janela do R Em uma sessão, o R guarda todos os objetos criados na sua memória, formando o que chamamos de workspace. Você pode salvar seu workspace, e carregá-lo posteriormente. Contudo, veremos que raramente isso é necessário. Aliás, não recomendado. Seu workspace será salvo como um arquivo ‘xxx.RData’. 1.4 Iniciando um projeto Abrir um projeto no RStudio/R basicamente significa definir um diretório de trabalho, onde por default serão salvos todos os seus arquivos de trabalho e o diretório a partir do qual todos os seus arquivos serão lidos. Um arquivo nome_do_projeto.Rproj será criado com as configurações básicas do seu projeto. Uma grande vantagem desse ambiente é que a maioria dos arquivos serão do tipo texto e podem ser abertos e lidos em qq editor de texto. A maneira mais fácil de criar um projeto é pelo menu do R Studio, mas essa é uma das poucas funcionalidades que iremos utilizar usando a barra de menu do aplicativo. O quanto antes aprendermos a usar os scripts maior será nossa produtividade. Abra um projeto e vamos explorar uma sessão: ls() ## [1] &quot;uncover&quot; 1.5 Entendendo os pacotes em R As funcionalidades do R podem ser estendidas por meio de pacotes. Esse é um conceito central que reflete um dos grandes diferenciais da plataforma R. Imagine que toda a comunidade científica pode contribuir com pacotes de código para a plataforma R. Tais pacotes podem ser facilmente instalados no seu computador e carregados na sua sessão. Neste momento a sua sessão/instalação está capacitada a executar todas as funcionalidades disponibilizadas pelo pacote instalado. O “Comprehensive R Archive Network (CRAN)” (https://cran.r-project.org/) é o repositório oficial de pacotes do R. Qualquer um pode submeter um pacote ao CRAN. É claro que o código precisa passar por um processo de avaliação e de formatação do código. Mas sendo aprovado, seu pacote fará parte de repositório e poderá ser instalado diretamente do R ou R Studio. Existem outros repositórios não oficiais, mas não serão abordados nesse curso. Os pacotes podem ser instalados a partir do RStudio ou diretamente do console R: install.packages(&quot;nome_do_pacote&quot;, dependences = TRUE) Uma vez instalado, o pacote precisa ser disponibilizado na sua sessão, o que é feito pelo comando library(). library(&quot;nome_do_pacote&quot;) Verifique quais pacote estão carregados na sua sessão usando search() search() É importante sempre manter os pacotes instalados atualizados, o que pode ser realizado pelo RStudio ou pelo console usando update.packages() O Ambiente do R está focado em permitir o trabalho colaborativo e a reprodutibilidade das pesquisa, logo pode ser que seja necessário tirar uma foto do seu ambiente para outro ussuário possa reproduzí-lo. Isso pode ser realizado usando a função sessionInfo(). sessionInfo() "],
["ConceitosBasicos.html", "Unidade 2 R Project - Conceitos Básicos 2.1 Iniciando pelo básico 2.2 Iniciando uma variável do um valor 2.3 Inspecionando os valores das variáveis 2.4 Como nomear suas variáveis 2.5 Atalhos 2.6 Use a assistência da interface 2.7 Chamando funções 2.8 R Markdown", " Unidade 2 R Project - Conceitos Básicos Referências utilizadas para esse capítulo: R for Data Science. Garrett Grolemund e Hadley Wickham (Grolemund and Wickham 2016) R programming for Data Science. Roger D. Peng (Peng 2015) E recentemente encontrei um ótimo livro em português, criado pelo Prof. Marcelo Perlin da UFRGS, cuja parte de introdução ao R é bem completa e se encaixa perfeitamente ao nosso curso. Processamento e Modelagem de Dados Financeiros com o R. Marcelo Perlin (Perlin 2017) 2.1 Iniciando pelo básico Vamos inicialmente usar R como uma calculadora! 1 / 40 * 1000 ## [1] 25 (50 + 31 + 7) / 3 ## [1] 29.33333 cos(pi / 2) ## [1] 6.123032e-17 Olhando R sob esse ponto de vista, é possível entender que a implementação da Linguagem R incorpora outros paradigmas de Linguagens de programação (Paradigma funcional), além daqueles que normalmente já estamos acostumados, como o Paradigma de orientação de objetos. Na verdade, na Linguagem R tudo é objeto! 2.2 Iniciando uma variável do um valor Quando atribuímos um valor a uma variável, estamos na verdade criando um objeto, onde um dos seus atributos é o valor daquela variável. No R novos objetos são criados com &lt;- (verifique qual atalho pode ser usado no seu Sistema operacional para gerar) &lt;-: x &lt;- 3 * 4 Todas os objetos criados em R são criados da mesma forma, usando um comando de atribuição: nome_do_objeto &lt;- valor Ao ler que o código, é como se fosse “o nome do objeto obtém valor”! Você fará muitas atribuições e digitar &lt;- pode se tornar cansativo. Tente não usar =: vai funcionar, mas vai causar confusão mais tarde. Em vez disso, use o atalho de teclado do RStudio: Alt + - (sinal de subtração). Observe que o RStudio automaticamente inclui espaços &lt;-, o que é uma boa prática de formatação de código. 2.3 Inspecionando os valores das variáveis x &lt;- 5 ## nada é impresso x ## auto-printing ## [1] 5 #`[1]` indica que o primeiro elemento contido em `x` é o valor `5`. print(x) ## o valor é impresso como resultado (raramente é usado, já que a opção anterior é mais prática) ## [1] 5 Obs: # é usado para inserir um comentário em R. Nada será executado. Outras atribuições: x &lt;- 1:20 x x &lt;- 1 # O valor anterior é sobrescrito x msg &lt;- &quot;hello&quot; #Para fazer a inicialização e ao mesmo tempo imprimir use (x &lt;- 1:10) # raramente usado Obs: O operador : é usado para criar sequência de inteiros. 2.4 Como nomear suas variáveis Nomes de objeto devem começar com uma letra, e conter apenas letras, números, _ e .. Se você quer que seus nomes sejam de fácil associação, então a recomendação é usar um padrão de codificação. Uma sugestão é o padrão snake case (meu_modelo) onde você separa palavras em letras minúsculas com _ Exemplos: eu_uso_snake_case otherPeopleUseCamelCase some.people.use.periods E_algumas.Pessoas_NAOusamPadrao 2.5 Atalhos esse_e_um_nome_longo &lt;- 2.5 Para inspecionar esse objeto, tente usar o funcionalidade auto completar do R Studio: Digete “esse”, pressione TAB, adicione caracteres até formar um prefixo único, então pressione ENTER. No caso de cometer um erro: esse_e_um_nome_longo deve ter valor 3.5 não 2,5. Use outro atalho de teclado para ajudá-lo a corrigi-lo. Digite esse, em seguida, pressione Ctrl/Cmd + seta para cima. Isso irá listar todos os comandos que você digitou que começam com aqueles caracteres. Use as setas para navegar e, em seguida, pressione ENTER para digitar novamente o comando. Mude de 2.5 a 3.5 e execute novamente. Outro detalhe: r_rocks &lt;- 2 ^ 3 Vamos tentar inspecionar esta variável: r_rock #&gt; Error: object &#39;r_rock&#39; not found R_rocks #&gt; Error: object &#39;R_rocks&#39; not found Há um contrato implícito entre você e o R: O R fará toda a computação tediosa para você, mas em troca, você deve ser completamente preciso em suas instruções. Ele é case sensitive 2.6 Use a assistência da interface Digite o código abaixo e note a assistência com as aspas emparelhadas: x &lt;- &quot;hello world&quot; Aspas e parênteses devem sempre vir em um par. RStudio faz o seu melhor para ajudá-lo, mas ainda é possível errar e acabar com uma incompatibilidade. Se isso acontecer, R irá mostrar-lhe o caractere de continuação de “+”: x &lt;- &quot;hello #+ O + diz-lhe que R está esperando por mais alguma entrada. Ele acha que você ainda não digitou tudo. Normalmente isso significa que você tenha esquecido ou um &quot; ou um ). Adicione o par ausente ou pressione ESC para abortar a expressão e tente novamente. Você também pode ver todas as variáveis/objetos criados no painel “Variáveis de Ambiente” no ‘R Studio’ Figura 2.1: Variáveis de ambiente visualizados no painel “Environment” no RStudio 2.7 Chamando funções R tem uma grande coleção de funções internas que são chamados assim: function_name(arg1 = val1, arg2 = val2, ...) Vamos tentar usar o seq(), que cria uma sequência de números. Digite ‘se’ e pressione TAB. Um popup mostra os possíveis comandos (funções). Digitando mais (um q), ou usando as setas cima/baixo, você pode selecionar a função ‘seq()’. Observe a dica flutuante que aparece, lembrando os argumentos da função e seu propósito. Se você quiser mais ajuda, pressione F1 para obter todos os detalhes no guia de ajuda no painel inferior direito. Pressione TAB uma vez mais, quando você selecionar a função que você quer. RStudio adicionará os parênteses correspondentes, abrindo ( e fechando ) parênteses para você. Digite os argumentos ‘1, 10’ e pressione ENTER. seq(1, 10) ## [1] 1 2 3 4 5 6 7 8 9 10 Se você fizer uma atribuição, não verá o valor da atribuição. Mas como vimos antes, é fácil verificar o valor da variável logo em seguida: y &lt;- seq(1, 10, length.out = 5) y ## [1] 1.00 3.25 5.50 7.75 10.00 Um atalho pode ser inserir o commando entre parênteses (pouco usado): (y &lt;- seq(1, 10, length.out = 5)) ## [1] 1.00 3.25 5.50 7.75 10.00 2.8 R Markdown Esse arquivo foi preparado usando o RMarkdown dentro do RStudio. Os arquivos de tipo Rmarkdown podem der utilizados para estender os scriptos em R para a geração de conteúdo em vários formatos, como HTML e PDF. Os blocos de código são inseridos ao longo de texto, os quais podem ser executados como scrpts ou na geração dos documentos. Os blocos de código são chamados de chunk e podem ser executados clicando o botão de run ou posicionando o cursor dentro do chunck e pressionando Ctrl+Shift+Enter. Para adicionar um novo chunck use insert chunch na barra de ferramentas ou pressione Ctrl+Alt+I. Se o seu arquivo markdown for do tipo notebook, ao salvar o seu arquivo .Rmd no RStudio, um arquivo HTML também será salvo. (Para visualizar uma prévia do seu notebook em HTML, pressione preview na barra de ferramentas ou as teclas Ctrl+Shift+K. References "],
["tipos-basicos-de-dados.html", "Unidade 3 Tipos Básicos de Dados 3.1 Números 3.2 Lógico 3.3 Sequência de Caracteres", " Unidade 3 Tipos Básicos de Dados Tudo em R é objeto!! R tem cinco classes básicas ou atômicas de objetos: numéro em geral (números reais) inteiro números complexos Valores lógicos (TRUE/FALSE) caractere (string) 3.1 Números Números em R são geralmente tratados como objetos (ex. Números reais) Se você precisa especificamente de um inteiro (raramente), é necessário especificar o sufuxo L O valor NaN(“not a number”) representa um valor associado a uma operação aritmética não definida ( e.g. 0 / 0); NaN pode também representar valores ausentes (como veremos mais adiante). 3.1.1 Numérico x &lt;- 5 x ## [1] 5 is.numeric(x) ## [1] TRUE is.integer(x) ## [1] FALSE 3.1.2 Inteiro (raramente usado) x &lt;- 5L x ## [1] 5 is.numeric(x) ## [1] TRUE is.integer(x) ## [1] TRUE 3.1.3 Números Complexos (Uso não muito comum) x &lt;- 1 + 4i x ## [1] 1+4i is.numeric(x) ## [1] FALSE is.integer(x) ## [1] FALSE is.complex(x) ## [1] TRUE 3.2 Lógico x &lt;- TRUE x ## [1] TRUE x &lt;- TRUE x &lt;- (3 &lt; 4) x ## [1] TRUE 3.3 Sequência de Caracteres x &lt;- &quot;Bem Vindo ao R e ao RStudio&quot; x ## [1] &quot;Bem Vindo ao R e ao RStudio&quot; "],
["estruturas-de-dados.html", "Unidade 4 Estruturas de dados 4.1 Vetores 4.2 Criando Vetores 4.3 Misturando Objetos 4.4 Coerção explícita 4.5 Atributos (Attributes) 4.6 Matrizes 4.7 cbind-ing and rbind-ing 4.8 Listas (list) 4.9 Fator (factor) 4.10 Valores ausentes (Missing Values) 4.11 Data Frames (Finalmente a cereja do bolo :)) 4.12 Nomes 4.13 Sumário", " Unidade 4 Estruturas de dados 4.1 Vetores A estrutura mais básica do R é um vetor Um vetor pode conter apenas objetos da mesma classe básica Existe um outro objeto chamado lista, que é representado como um vetor, mas pode conter objetos de classes diferentes Vetores vazios podem ser criados com a função vector(). O operador : é usado para gerar/representar uma sequência de números. x &lt;- 1:20 x ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 4.2 Criando Vetores A função c() concatena os seus argumentos em um vetor. x &lt;- c(0.5, 0.6) ## numeric x &lt;- c(TRUE, FALSE) ## logical x &lt;- c(T, F) ## logical x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) ## character x &lt;- 9:29 ## integer x &lt;- c(1+0i, 2+4i) ## complex Para a criação de um vetor vazio podemos usar a função vector() x &lt;- vector(&quot;numeric&quot;, length = 10) x ## [1] 0 0 0 0 0 0 0 0 0 0 4.3 Misturando Objetos Quando objetos diferente são misturados em um vetor, a coerção ajusta os tipos de modo que todos elementos mantenham sejam da mesma classe. y &lt;- c(1.7, &quot;a&quot;) ## character y &lt;- c(TRUE, 2) ## numeric y &lt;- c(&quot;a&quot;, TRUE) ## character 4.4 Coerção explícita Objetos de uma classe podem ser sua classe alterada usando as funções as.*() x &lt;- 0:6 class(x) # &quot;integer&quot; ## [1] &quot;integer&quot; as.numeric(x) ## [1] 0 1 2 3 4 5 6 as.logical(x) # FALSE .... ## [1] FALSE TRUE TRUE TRUE TRUE TRUE TRUE as.character(x) # &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; ## [1] &quot;0&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; Coerções não permitidas geram NA (Não avaliado/Não disponível). x &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;) as.numeric(x) ## Warning: NAs introduzidos por coerção ## [1] NA NA NA as.logical(x) ## [1] NA NA NA as.complex(x) ## Warning: NAs introduzidos por coerção ## [1] NA NA NA 4.5 Atributos (Attributes) Os objetos em possuem vários atributos: - nomes, dimnames - dimensão (e.g. matrizes, arrays) - classe - comprimento - outras atributos definidos pelo usuário/metadata O nome dos atributos de um objeto pode ser acessado usando a função attributes(). 4.6 Matrizes Matrizes são vetores com duas ou mais dimensões. A dimensão é na verdade um vetor com dois valores inteiros (número de linhas, número d colunas). Uma característica importante é que todos os elementos de uma matriz são do mesmo tipo. Use attributes para explorar a estrutura de um tipo de dados. m &lt;- matrix(nrow = 2, ncol = 3) m ## [,1] [,2] [,3] ## [1,] NA NA NA ## [2,] NA NA NA dim(m) ## [1] 2 3 attributes(m) ## $dim ## [1] 2 3 Matrizes normalmente são construídas por colunas, de modo que uma sequência de dados é lido como se estivesse se iniciando na posição superior esquerda, elemento na [linha,coluna] = [1,1], continuando até o último elemento da coluna, e assim por diante. m &lt;- matrix(1:6, nrow = 2, ncol = 3) m ## [,1] [,2] [,3] ## [1,] 1 3 5 ## [2,] 2 4 6 Contudo, as matrizes podem também ser criadas a partir de vetores, basta definir seus atributos d dimensão, como no exemplo abaixo: m &lt;- 1:10 m ## [1] 1 2 3 4 5 6 7 8 9 10 dim(m) &lt;- c(2, 5) m ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 4.7 cbind-ing and rbind-ing Existem várias situações onde mais prático criar matrizes adicionando colunas as já existentes (column-binding) ou adicionando linhas (row-binding_) com cbind() and rbind(). x &lt;- 1:3 y &lt;- 10:12 cbind(x, y) ## x y ## [1,] 1 10 ## [2,] 2 11 ## [3,] 3 12 rbind(x, y) ## [,1] [,2] [,3] ## x 1 2 3 ## y 10 11 12 4.8 Listas (list) Listas é uma poderosa estrutura de dados. É utilizada de várias formas no contexto de R, muitas vezes passando desapercebida. Uma lista nada mais é que um vetor que pode conter elementos de diferentes classes. x &lt;- list(1,&quot;a&quot;,TRUE, 1 + 4i ) x ## [[1]] ## [1] 1 ## ## [[2]] ## [1] &quot;a&quot; ## ## [[3]] ## [1] TRUE ## ## [[4]] ## [1] 1+4i x[1] # Primeiro classe da lista ## [[1]] ## [1] 1 x[[1]] # Primeiro elemento da primeira classe da lista ## [1] 1 4.9 Fator (factor) Fatores são usados para representar valores de variáveis categóricas. Esses fatores podem ser ordenados ou não-ordenados. Pode-se pensar nos fatores como sendo números inteiros, cada um representando uma categoria representado por um nome padrão (label). Fatores são tratados de maneira distinta em algums modelos, como por exemplo regressão linear lm() e regressão linear generalizada glm() Usar fatores com nomes é melhor do que usar números devido a legibilidade e transparências. Por exemplo, usar “Masculino” e “Feminino” descreve melhor os possiveis valores da variável categoria “Sexo” do que os valores 1 e 2. x &lt;- factor(c(&quot;yes&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;no&quot;)) x ## [1] yes yes no yes no ## Levels: no yes table(x) ## x ## no yes ## 2 3 unclass(x) # retorna x sem os atributos da classe factor, ou seja, os níveis(levels) ## [1] 2 2 1 2 1 ## attr(,&quot;levels&quot;) ## [1] &quot;no&quot; &quot;yes&quot; A ordem dos níveis levels pode ser definida usando o argumento levels na função factor(). Isso pode ser importante em modelos lineares como a regressão linear já que o primeiro nível é usado como base. x &lt;- factor(c(&quot;yes&quot;, &quot;yes&quot;, &quot;no&quot;, &quot;yes&quot;, &quot;no&quot;), levels = c(&quot;yes&quot;, &quot;no&quot;)) x ## [1] yes yes no yes no ## Levels: yes no Usando a função attributes attributes(x) #Aqui eu encontro o método &quot;levels&quot; ## $levels ## [1] &quot;yes&quot; &quot;no&quot; ## ## $class ## [1] &quot;factor&quot; levels(x) ## [1] &quot;yes&quot; &quot;no&quot; 4.10 Valores ausentes (Missing Values) “Missing values” são definidos por NA (non-available) or NaN (not a number) e não são permitidos em algumas operações matemática. Muito usado!!!! Não substimen sua utilidade quando estivermos limpando e ajustando os dados. is.na() é usado para testar objetos se eles são NA is.nan() é usado para testar elementos se eles são NaN NA possuem classe. Ou seja, existem inteiros NA, caracteres (character) NA e etc. NaN é usado para representar resultados de operações matemáticas não definidas, como 0/0 ou infinito - ìnfinito. O NaN é também NA mas o inverso não é verdadeiro x &lt;- c(1, 2, NA, 10, 3) is.na(x) ## [1] FALSE FALSE TRUE FALSE FALSE is.nan(x) ## [1] FALSE FALSE FALSE FALSE FALSE x &lt;- c(1, 2, NaN, NA, 4) is.na(x) ## [1] FALSE FALSE TRUE TRUE FALSE is.nan(x) ## [1] FALSE FALSE TRUE FALSE FALSE 4.11 Data Frames (Finalmente a cereja do bolo :)) Data frames é uma estrutura de dados usada para armazenar dados em tabela. A diferença para matriz é que em data frames cada coluna pode conter um tipo de vaiável. Ou seja, é simplesmente uma tabela Pode ser visto como um caso especial de lista onde todos os elementos da lista possuem o mesmo comprimento. Cada elemento da lista é na verdade uma coluna de uma tabela, e o comprimento de cada elemento da lista o número de linhas da tabela. Diferente das matrizes, data frames podem armazenar diferentes classes de objetos, uma em cada coluna (como uma lista); Todos os elementos das matrizes são da mesma classe Data frames possuem um atributo especial chamado row.names Data frames é o formato normalmente utilizado na importação de dados, resultado das funções read.table() ou read.csv() Pode ser convertido para matriz por meio da função data.matrix() x &lt;- data.frame(foo = 1:4, bar = c(T, T, F, F)) x ## foo bar ## 1 1 TRUE ## 2 2 TRUE ## 3 3 FALSE ## 4 4 FALSE nrow(x) ## [1] 4 ncol(x) ## [1] 2 4.12 Nomes Objetos em R podem ter nomes associados, o que torna os códigos mais fácil de serem lidos e compreendidos. x &lt;- 1:3 names(x) ## NULL names(x) &lt;- c(&quot;foo&quot;, &quot;bar&quot;, &quot;norf&quot;) x ## foo bar norf ## 1 2 3 names(x) ## [1] &quot;foo&quot; &quot;bar&quot; &quot;norf&quot; Listas também podem ter nomes associados x &lt;- list(a = 1, b = 2, c = 3) x ## $a ## [1] 1 ## ## $b ## [1] 2 ## ## $c ## [1] 3 E matrizes. m &lt;- matrix(1:4, nrow = 2, ncol = 2) dimnames(m) &lt;- list(c(&#39;a&#39;, &#39;b&#39;), c(&#39;c&#39;, &#39;d&#39;)) m ## c d ## a 1 3 ## b 2 4 4.13 Sumário Estruturas de Dados em R classes básicas: numérica, lógica, caracter, inteiro, número complexo vetores, listas fatores missing values data frames E finalmente, é importante entender como os nomes são associados aos objetos em R "],
["mais-operacoes-basicas-em-r.html", "Unidade 5 Mais operações básicas em R 5.1 Função sessionInfo()", " Unidade 5 Mais operações básicas em R Para esse tópico vamos seguir como referência o capítulo 2 no livro do Marcelo Perlim. Finalmente, é importante ainda enfatizar os seguinte tópicos: 5.1 Função sessionInfo() Quando começamos a trabalhar com R, precisamos entender que estamos dentro de uma sessão, a qual contém nossas variáveis de ambiente, nossos dados, os pacotes carregados. Quando iniciamos uma nova sessão em R (ou um novo projeto), um conjunto totalmente novo e vazio é criado, assim teremos novamente que carregar nossos dados,variáveis de ambiente, pacotes e etc. Claro que todo esse comportamento pode ser configurado, mas vamos comecar com o básico :-) Muitas vezes precisamos tirar uma foto da sessão para saber o que está carregado, para que outro analista possa replicar o mesmo ambiente e eventualmente confirmar as análises realizadas. Para isso existe a função sessionInfo() que tem exatamente esta tarefa, mostrando quais pacotes estão carregados, inclusive anontando a versão do pacote utilizado. Teste a função sessionInfo() e verifique o que está carregado na sua sessão! sessionInfo() "],
["bancos-de-dados.html", "Unidade 6 Bancos de Dados", " Unidade 6 Bancos de Dados O Ambiente R já traz na sua biblioteca base vários conjuntos de dados que podem ser utilizados para testes. Para explorar esses dados use a função data(). data() # Apresenta os vários conjuntos de dados disponíveis na sua sessão no R. help(&quot;USArrests&quot;) # Abre na janela help informações sobre esses dados data(&quot;iris&quot;) # Carrega os dados na sua sessão É comum os pacotes incorporarem outros dados que são utilizados no manual do pacote para explorar a funcionalidade do mesmo. library(ggplot2) # Carregue o pacote ggplot2 data() # Verifique os dados adicionais disponibilizados por esse pacote "],
["criacao-de-projetos-em-r.html", "Unidade 7 Criação de Projetos em R 7.1 Criando Projetos no RStudio", " Unidade 7 Criação de Projetos em R 7.1 Criando Projetos no RStudio Um projeto em R é um container da sua sessão. Todo o seu ambiente, variáveis e pacotes carregados, ficam confinados no projeto. Fisicamente, o seu projeto é um diretório contendo um arquivo “nome_do_projeto.Rproj”. A forma como seu projeto é organizado pode contribuir significativamente no resultado do seu trabalho. Cada pesquisador possui seu estilo próprio de organizar seu projeto. Enquanto você ainda não desenvolveu o seu, vou sugerir uma organização simples e bem básica que incorpora algumas das boas práticas a serem observadas quando trabalhando em projetos R dentro do RStudio. A base para este esquema foi criada a partir das recomendações da pesquisadora Page Piccinini, e inicialmente se resumirá a criar diretórios para organizar suas análises. 7.1.1 Criando diretórios no seu projeto Inicialmente crie seu projeto “ML_Aula_1” no diretório “ML_Aula_1” . Você pode criar o diretório quando criar o projeto no RStudio ou simplesmente criá-lo antes criar um novo projeto no RStudio. Dentro do diretório do seu projeto, crie os seguintes subdiretórios: dados: Esses diretório conterá os dados usados na sua análise. Normalmente em uma versão ainda bruta, mas ainda não subetida ao préprocessamento. Dessa forma será mais simples escrever seus sripts importando os dados desta fonte, já convertidos para o formato Rdata, ao invés de importar os dados da fonte original (excel, csv, url e etc.) figuras: Como várias figuras vão sendo geradas ao longo da análise, é interessante salvar neste diretório algumas cópias para relatórios preliminares. scritps: Esse é um dos diretórios mais importantes do seu projeto. Nele estarão todos os seus scrits (arquivos de análise), os quais serão aos poucos refinados durante o processo de análise. reports: Aqui serão criados os arquivos geradores do seus relatórios de análise, que podem ser arquivos markdown criados no próprio ambiente do RStudio, arquivos em Latex, MS Word e etc. 7.1.2 Scripts de análise No diretório scripts uma boa dica dica a ser seguida é a indicada por Marcelo Perlin no capítulo 9 do seu livro, onde ele recomenda organizar os scrips de pesquisa em quatro etapas: Importação dos dados Limpeza e estruturação dos dados Modelagem e teste de hipóteses Reportando os resultados Mas o interessante é a sugestão é criar uma nomenclatura para a nomeação dos scripts, relacionadas sequenciamente com as etapas da pesquisa. “Um exemplo seria nomear o código de importação de dados como 1-Import-and-clean-data.R, o código de modelagem como 2-build-report-models.R e assim sucessivamente. O efeito prático é que o uso de um contador na primeira letra do nome do arquivo faz com que a ordem de execução do programa fique bastante clara.” — Marcelo Perlin Mais adiante veremos como estruturar os scripts internamente. "],
["criacao-de-graficos-basicos.html", "Unidade 8 Criação de Gráficos Básicos 8.1 Sumário dos 5 números 8.2 Importância da visualização dos dados 8.3 Tipos básicos de gráficos1 8.4 Uma variávél contínua 8.5 Variável categórica (ou discreta) 8.6 Duas Variáveis contínuas 8.7 Duas Variáves categóricas 8.8 Duas variáveis: Uma categórica e outra numérica 8.9 Três variáveis discretas (categorias ou fatores em R) 8.10 Três Variáveis: Uma númérica e duas categóricas 8.11 Três variáveis: Duas numéricas e uma variável categórica 8.12 Três variáveis numéricas", " Unidade 8 Criação de Gráficos Básicos O objetivo dessa sessão é a familiarização com os tipos básicos de gráfico que podem ser usados para descrever o comportamento e o relacionamento entre os dados de um estudo estatístico. 8.1 Sumário dos 5 números O sumário dos 5 números é conhecido como um conjunto de estatísticas descritivas que revelam os percintis gerais mais significativos em uma amostra de dados. Estes são: 1. Mínimo 2. Primeiro quartil 3. Mediana 4. Terceiro quartil 5. Máximo Por exemplo, em R podemos obter esse sumário por meio do comando summary. Vamos carregar os dados “cars” que apresenta a velocidade e a distância de parada de alguns carros (gravado em 1920!). help(&quot;cars&quot;) data(&quot;cars&quot;) summary(cars) 8.2 Importância da visualização dos dados Apesar das várias medidas estatísticas descritivas disponível, a Figura 8.1 mostra porque a visualização dos dados é muito importante. Figura 8.1: Artigo Same Stats, Diferent Graphs (Matejka and Fitzmaurice 2017) 8.3 Tipos básicos de gráficos1 Inicialmente, será necessário simular alguns dados para serem usados como fonte na geração de gráficos. Os dados serão armazenados em um data frame contendo 3 variáveis categóricas (fatores em R) e 4 variáveis contínuas. ## Simulando os dados ## 3 variáveis categóricas FacVar1 = as.factor(rep(c(&quot;level1&quot;, &quot;level2&quot;), 25)) FacVar2 = as.factor(rep(c(&quot;levelA&quot;, &quot;levelB&quot;, &quot;levelC&quot;), 17)[-51]) FacVar3 = as.factor(rep(c(&quot;levelI&quot;, &quot;levelII&quot;, &quot;levelIII&quot;, &quot;levelIV&quot;), 13)[-c(51:52)]) ## 4 variáveis númericas set.seed(123) # referência para uniformizar as variáveis geradas NumVar1 = round(rnorm(n = 50, mean = 1000, sd = 50), digits = 2) ## Distribuição Normal NumVar2 = round(runif(n = 50, min = 500, max = 1500), digits = 2) ## Distribuição Uniforme NumVar3 = round(rexp(n = 50, rate = 0.001)) ## Distribuição exponencial NumVar4 = 2001:2050 simData = data.frame(FacVar1, FacVar2, FacVar3, NumVar1, NumVar2, NumVar3, NumVar4) 8.4 Uma variávél contínua 8.4.1 Gráfico de pontos (scatter) plot(simData$NumVar1, type = &quot;o&quot;) ## Index plot 8.4.2 Histograma hist(simData$NumVar1) ## histogram 8.4.3 Curva da densidade de probabilidade plot(density(simData$NumVar1)) ## Kernel density plot 8.4.4 Boxplot boxplot(simData$NumVar1) ## box plot 8.5 Variável categórica (ou discreta) 8.5.1 Gráfico de barras (Total) plot(simData$FacVar3) ## bar plot 8.6 Duas Variáveis contínuas plot(simData$NumVar1, type = &quot;o&quot;, ylim = c(0, max(simData$NumVar1, simData$NumVar2))) ## index plot with one variable lines(simData$NumVar2, type = &quot;o&quot;, lty = 2, col = &quot;red&quot;) ## add another variable 8.6.1 Gráfico de densidade de probabilidade (density plots) Exemplo de https://stat.ethz.ch/pipermail/r-help/2006-August/111865.html, onde um gráfico “vazio” é produzido e depois preeenchido com linhas (função lines()). dv1 = density(simData$NumVar1) dv2 = density(simData$NumVar2) plot(range(dv1$x, dv2$x), range(dv1$y, dv2$y), type = &quot;n&quot;, xlab = &quot;NumVar1(red) and NumVar2 (blue)&quot;, ylab = &quot;Density&quot;) lines(dv1, col = &quot;red&quot;) lines(dv2, col = &quot;blue&quot;) 8.6.2 Gráfico de pontos x,y (scatterplots) plot(simData$NumVar1, simData$NumVar2) 8.7 Duas Variáves categóricas 8.7.1 Mosaico (Mosaic plot) plot(table(simData$FacVar2, simData$FacVar3)) 8.7.2 Gráfico de Barras (barplots) bartable = table(simData$FacVar2, simData$FacVar3) ## get the cross tab barplot(bartable, beside = TRUE, legend = levels(unique(simData$FacVar2))) ## plot 8.7.3 Barras Empillhadas (stacked) barplot(bartable, legend = levels(unique(simData$FacVar2))) ## stacked 8.7.4 Barras Empillhadas 100% (stacked 100%) Transformando a tabela para proporções barplot(prop.table(bartable, 2) * 100, legend = levels(unique(simData$FacVar2))) ## usando prop.table 8.8 Duas variáveis: Uma categórica e outra numérica 8.8.1 Box plots: variáveis numéricas por categoria plot(simData$FacVar1, simData$NumVar1) 8.8.2 Gráfico de densidade de probabilidade por categoria level1 = simData[simData$FacVar1 == &quot;level1&quot;, ] level2 = simData[simData$FacVar1 == &quot;level2&quot;, ] dv3 = density(level1$NumVar1) dv4 = density(level2$NumVar1) plot(range(dv3$x, dv4$x), range(dv3$y, dv4$y), type = &quot;n&quot;, xlab = &quot;NumVar1 at Level1 (red) and NumVar1 at Level2 (blue)&quot;, ylab = &quot;Density&quot;) lines(dv3, col = &quot;red&quot;) lines(dv4, col = &quot;blue&quot;) 8.8.3 Média de uma variável numérica considerando sua categoria Verifique como funciona aggregate(), e qual é o retorno de cada função usada como argumento. list(simData$FacVar3) aggregate(simData$NumVar1, list(simData$FacVar3), mean) meanagg = aggregate(simData$NumVar1, list(simData$FacVar3), mean) meanagg ## Group.1 x ## 1 levelI 998.8154 ## 2 levelII 992.0538 ## 3 levelIII 1010.3125 ## 4 levelIV 1006.7492 dotchart(meanagg$x, labels = meanagg$Group.1) ## Dot Chart Gráfico de barras usando a média barplot(meanagg$x, names.arg = meanagg$Group.1) ## Bar plot Questão: O gráfico anterior é aproproado para comparar as médias (um valor pontual)? Escolha um gráfico melhor :) 8.9 Três variáveis discretas (categorias ou fatores em R) Arrumando os gráficos matricialmente com a função par() par(mfrow = c(1, 2)) bar1table = table(level1$FacVar2, level1$FacVar3) barplot(bar1table, beside = TRUE, main = &quot;FacVar1=level1&quot;) bar2table = table(level2$FacVar2, level2$FacVar3) barplot(bar2table, beside = TRUE, main = &quot;FacVar1=level2&quot;, legend = levels(unique(level2$FacVar2))) par(mfrow = c(1,1)) #retornando ao normal 8.10 Três Variáveis: Uma númérica e duas categóricas 8.10.1 Boxplot considerando a interação entre as duas variáveis categóricas Considerando que cada variável aleatória tem 3 categorias, existem seis pares possíves, cada um podendo influenciar a variável contínua de maneira distinta. boxplot(NumVar1 ~ interaction(FacVar1, FacVar2), data = simData) 8.10.2 Média da variável numérica para cada par de interação das variáveis categóricas meanaggg = aggregate(simData$NumVar1, list(simData$FacVar1, simData$FacVar2), mean) meanaggg = meanaggg[order(meanaggg$Group.1), ] meanaggg$color[meanaggg$Group.2 == &quot;levelA&quot;] = &quot;red&quot; meanaggg$color[meanaggg$Group.2 == &quot;levelB&quot;] = &quot;blue&quot; meanaggg$color[meanaggg$Group.2 == &quot;levelC&quot;] = &quot;darkgreen&quot; meanaggg ## Group.1 Group.2 x color ## 1 level1 levelA 1004.8489 red ## 3 level1 levelB 996.3175 blue ## 5 level1 levelC 1011.7713 darkgreen ## 2 level2 levelA 1004.5125 red ## 4 level2 levelB 989.9144 blue ## 6 level2 levelC 1004.0450 darkgreen dotchart(meanaggg$x, labels = meanaggg$Group.2, groups = meanaggg$Group.1, color = meanaggg$color) ## dotchart 8.10.3 Gráfico de interação (interaction plot) Uma categoria eixo x e a outra no símbolo utilizado. interaction.plot(meanaggg$Group.2, meanaggg$Group.1, meanaggg$x, type = &quot;b&quot;, col = c(1:2), pch = c(18, 24)) ## interaction plot - line plots of means 8.10.4 Gráfico de barras Veja a dificuldade de identificar tais variações em um gráfico de barras par(mfrow = c(1, 2)) meanaggg ## Group.1 Group.2 x color ## 1 level1 levelA 1004.8489 red ## 3 level1 levelB 996.3175 blue ## 5 level1 levelC 1011.7713 darkgreen ## 2 level2 levelA 1004.5125 red ## 4 level2 levelB 989.9144 blue ## 6 level2 levelC 1004.0450 darkgreen level1 = meanaggg[meanaggg$Group.1 == &quot;level1&quot;, ] level2 = meanaggg[meanaggg$Group.1 == &quot;level2&quot;, ] barplot(level1$x, names.arg = level1$Group.2, main = &quot;FacVar1=level1&quot;) barplot(level2$x, names.arg = level2$Group.2, main = &quot;FacVar1=level2&quot;) par(mfrow = c(1, 1)) 8.11 Três variáveis: Duas numéricas e uma variável categórica 8.11.1 Gráfico de pontos usando cor Aqui a cor é utilizada para identificar o valor da variável categorica plot(simData$NumVar1, simData$NumVar2, col = simData$FacVar1) legend(&quot;topright&quot;, levels(simData$FacVar1), fill = simData$FacVar1) #Usando pontos sólidos para melhorar a visiualização plot(simData$NumVar1, simData$NumVar2, col = simData$FacVar1, pch = 19) legend(&quot;topright&quot;, levels(simData$FacVar1), fill = simData$FacVar1) 8.12 Três variáveis numéricas 8.12.1 Gráficos de Linhas Considerando que NumVar4 varia de 2001 até 2050, vamos assumir que a mesma representaria uma data aque será usada no eixo x plot(simData$NumVar4, simData$NumVar1, type = &quot;o&quot;, ylim = c(0, max(simData$NumVar1, simData$NumVar2))) ## join dots with lines lines(simData$NumVar4, simData$NumVar2, type = &quot;o&quot;, lty = 2, col = &quot;red&quot;) ## add another line Observe que lines() permite que a gráfico poderá ser montado em níveis. Essa é uma funcionalidade muito útil, mas ainda limitada no sistema de gráficos do pacote básico. Veremos mais adiante um pacote mais poderoso implementado para explorar melhor esta possibilidade. 8.12.2 Gráfico de bolhas2 Esse é um gráfico que incorpora nos pontos definidos pelas variáveis NumVar1 and NumVar2 a informação da variável NumVar3, usando seu valor para definir o tamanho do ponto a ser plotado. radius &lt;- sqrt(simData$NumVar3/pi) symbols(simData$NumVar1, simData$NumVar2, circles = radius, inches = 0.25, fg = &quot;white&quot;, bg = &quot;red&quot;, main = &quot;Tamanho dado por NumVar3&quot;) 8.12.3 Gráfico de pares Finalmente, um gráfico de pontos (Scatterplot) na forma de uma matriz simétrica que apresenta a correlação espacial entre os pares das variáveis numéricas, coloridas por uma variável discreta. pairs(simData[, 4:7], col = simData$FacVar1, pch = 19) Na verdade, a medida que vamos incrementando a apresentação de mais informações nos gráficos, os comandos passam a ganhar maior complexidade quando usamos apenas o pacote base. No próximo capítulo veremos um pacote especialmente implementado para lidar com essa problemática, facilitado em muito a criação de gráficos mais informativos. References "],
["graficos-com-o-ggplot2.html", "Unidade 9 Gráficos com o ggplot2 9.1 Introdução 9.2 Gramática dos gráficos (Wilkinson 2005) 9.3 Primeiro exemplo 9.4 Estrutura para montagem de um gráfico 9.5 Mapeamento Visual e geometrias (Aesthetic Mapping and geometrics) 9.6 Pontos (Scatterplot) 9.7 Linhas (Ex. Regressão linear) 9.8 Smoothers 9.9 Texto (Label Points) 9.10 Aesthetic Mapping VS Assignment 9.11 Exercicio I 9.12 Recursos adicionais", " Unidade 9 Gráficos com o ggplot2 9.1 Introdução O pacote ggplot2 (Wickham and Chang 2016) permite mesmo aos usuários sem muito conhecimento de R a produzirem gráficos com aparência profissional. Mais do que isso, possibilita que os analístas de dados possam explorar e comunicar melhor as evidências existentes em um conjunto de dados, tornando seu trabalho como um todo mais robusto. 9.2 Gramática dos gráficos (Wilkinson 2005) O pacote ggplot2 incorpora um conceito moderno sobre como constriur apresentações gráficas. Esse conceito está baseado na ideia de que um gráfico deve ser construído em camadas sucessivas, e tais camadas aos poucos vão dando forma a ideia a ser comunicada. As camadas de um gráfico são (termo em inglês entre parênteses): - dados (data) - mapeamento visual (aesthetic mapping) - geometria (geometric object) - transformações (statistical transformations) - escalas (scales) - sistema de coordenadas (coordinate system) - posição (position adjustments) - faces (faceting) Essa organização permite que elementos gráficos sejam combinados de maneira flexível, sejam refinados aos poucos partindo de ideias mais abstratas. Além do que a alteração de uma camada não compromete a consitências das demais. Por exemplo, mudar o símbolo ou a cor dos pontos. Existem outros pacotes gráficos em R, alguns independentes mas outros que estendem ainda mais a abrangência do pacote ggplot2, como por exemplo: - Gráficos 3-D (pacote rgl) - Plotagem de grafos (pacote *igraph*) - Gráficos interativos (pacote *ggvis*) Para essa sessão, a referência utilizada é o material do workshop “Introduction to R” realizado em Fevereiro/2017 pelo Research consulting for the Harvard community - Data Science Services - Harvard University, confeccionado principalmente por Ista Zahn. 9.3 Primeiro exemplo 9.3.1 Dados: “Housing prices” Fonte dos Dados [https://www.lincolninst.edu/subcenters/land-values/land-prices-by-state.asp] # Importe os dados (arquivo landdata-states-2016q1.xls). housing &lt;- read.csv(&quot;Dados/ggplot2/landdata-states.csv&quot;) head(housing[1:5]) ## State region Date Home.Value Structure.Cost ## 1 AK West 2010.25 224952 160599 ## 2 AK West 2010.50 225511 160252 ## 3 AK West 2009.75 225820 163791 ## 4 AK West 2010.00 224994 161787 ## 5 AK West 2008.00 234590 155400 ## 6 AK West 2008.25 233714 157458 9.3.2 ggplot2 VS Base Comparado com o pacote base, ggplot2 : - comandos com mais texto para gráficos simples - porém mais comandos mais simples para gráficos complexos - dados sempre devem estar em um `data.frame` - usa uma sistemática diferente para adicionar os elementos gráficos Como já vimos, para montar um histograma com o pacote base: hist(housing$Home.Value) Já usando ggplot2: library(ggplot2) #não esqueça de carregar e instalar o pacote ggplot(housing, aes(x = Home.Value)) + geom_histogram() ## `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Obs: ‘+’ significa que o próximo comando será somado na definição do gráfico Base wins! 9.3.3 ggplot2 VS base agora com gráficos mais complexos: O gráfico apresenta a evolução dos preços das casas em dois estados americanos, onde os pontos de cada estado possui uma cor distinta. plot(Home.Value ~ Date, data=subset(housing, State == &quot;MA&quot;)) points(Home.Value ~ Date, col=&quot;red&quot;, data=subset(housing, State == &quot;TX&quot;)) legend(1975, 400000, c(&quot;MA&quot;, &quot;TX&quot;), title=&quot;State&quot;, col=c(&quot;black&quot;, &quot;red&quot;), pch=c(1, 1)) Já com ggplot2: ggplot(subset(housing, State %in% c(&quot;MA&quot;, &quot;TX&quot;)), aes(x=Date, y=Home.Value, color=State))+ geom_point() ggplot2 wins! 9.4 Estrutura para montagem de um gráfico ggplot(data = &lt;default data set&gt;, aes(x = &lt;default x axis variable&gt;, y = &lt;default y axis variable&gt;, ... &lt;other default aesthetic mappings&gt;), ... &lt;other plot defaults&gt;) + geom_&lt;geom type&gt;(aes(size = &lt;size variable for this geom&gt;, ... &lt;other aesthetic mappings&gt;), data = &lt;data for this point geom&gt;, stat = &lt;statistic string or function&gt;, position = &lt;position string or function&gt;, color = &lt;&quot;fixed color specification&quot;&gt;, &lt;other arguments, possibly passed to the _stat_ function) + scale_&lt;aesthetic&gt;_&lt;type&gt;(name = &lt;&quot;scale label&quot;&gt;, breaks = &lt;where to put tick marks&gt;, labels = &lt;labels for tick marks&gt;, ... &lt;other options for the scale&gt;) + theme(plot.background = element_rect(fill = &quot;gray&quot;), ... &lt;other theme elements&gt;) 9.5 Mapeamento Visual e geometrias (Aesthetic Mapping and geometrics) 9.5.1 Aesthetic Mapping Em ggplot2 aesthetic significa “algo que pode ser visto”. Exemplo: - position (i.e., eixos x e y) - color (cor externa) - fill (cor interna usada para preencher) - shape (tipo de símbolo no caso de pontos) - linetype (tipo de linha) - size (tamanho) Cada tipo de objeto geométrico geom aceita somente um subconjunto das aesthetic, que são inseridas via função aes(). 9.5.2 Objetos geométricos (geom) Os objetos geométricos são os símbolos usados em um grafo. Exemplo: - pontos (`geom_point&#39;, para scatter plots, dot plots, etc) - linhas (`geom_line&#39;, para séries temporais, linhas de tendência, etc) - boxplot (`geom_boxplot&#39;, para boxplots!) - Um gráfico deve ter pelo menos um geomm; Nào há limite - podem ser adicionados como uma camada usando o sinal de `+` Uma lista das geom_ disponíveis pode ser visualizada usando o comando help.search(&quot;geom_&quot;, package = &quot;ggplot2&quot;) ou simplesmente teclando geom_&lt;tab&gt; em uma boa IDE R (como o Rstudio) 9.6 Pontos (Scatterplot) `geom_point’ requer que pelo menos o mapeamento de x e y tenham sido feitos. Os outros são opcionais. hp2001Q1 &lt;- subset(housing, Date == 2001.25) ggplot(hp2001Q1, aes(y = Structure.Cost, x = Land.Value)) + geom_point() Usando a log() para transformar a variável no eixo x. ggplot(hp2001Q1, aes(y = Structure.Cost, x = log(Land.Value))) + geom_point() 9.7 Linhas (Ex. Regressão linear) Como já foi dito, um gráfico usando ggplot2 pode conter mais de uma geom. Nesse caso, funciona como novas camadas fossem acrescentadas ao gráfico. Nesse exemplo, vamos incorporar ao gráfico uma linha de predição baseada na regressão linear (veremos adiamte mais detalhadamente esse assunto): hp2001Q1$pred.SC &lt;- predict(lm(Structure.Cost ~ log(Land.Value), data = hp2001Q1)) p1 &lt;- ggplot(hp2001Q1, aes(x = log(Land.Value), y = Structure.Cost)) p1 + geom_point(aes(color = Home.Value)) + geom_line(aes(y = pred.SC)) Obs: No chunk anterior a variável p1 contém a primeira camada do gráfico, e vamos reutilizá-la em outros exemplos abaixo. Aqui usamos duas geom, sendo que a cor dos pontos foi associada também a uma variável do data.frame. Automaticamente uma legenda foi criada e posicionada. 9.8 Smoothers Esse geom_ inclui uma linha de predição e uma faixa de intervalo de confiança considerando os pontos informados em aes(). Desta vez vamos reaproveitar nossa variável p1. p1 + geom_point(aes(color = Home.Value)) + geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; 9.9 Texto (Label Points) p1 + geom_text(aes(label=State), size = 3) obs: Para mais possibilidades com textos existe o pacote ggrepel (???). ## install.packages(&quot;ggrepel&quot;) library(&quot;ggrepel&quot;) p1 + geom_point() + geom_text_repel(aes(label=State), size = 3) 9.10 Aesthetic Mapping VS Assignment É importante frisar que as variáveis são mapeadas visualmente dentro da função aes(), enquanto que mapementos visual fixo (fixed aesthetics) como o tamanho de pontos deve ser realizado fora de aes(). Por exemplo: p1 + geom_point(aes(size = 2), # Errado! 2 não é uma variável color=&quot;red&quot;) # ok -- todos os pontos devem ser *red* Mais de uma variável mapeada em aes(): p1 + geom_point(aes(color=Home.Value, shape = region)) ## Warning: Removed 1 rows containing missing values (geom_point). 9.11 Exercicio I Os dados para este exercício estão em no arquivo ‘EconomistData.csv’. A fonte original dos dados é: - http://www.transparency.org/content/download/64476/1031428 - http://hdrstats.undp.org/en/indicators/display_cf_xls_indicator.cfm?indicator_id=103106&amp;lang=en Esses dados revelam o Índice de Desenvolvimento Humano(HDI) e o Índice Corrupção Perceptível(CPI) de diversos países. dat &lt;- read.csv(&quot;Dados/ggplot2/EconomistData.csv&quot;) head(dat) Se tudo estive correto, o comando abaixo deve funcionar: 1. Crie um gráfico de pontos (scatter plot) com CPI no eixo x e HDI no eixo y. 2. Colorir os pontos em azul (blue). 3. Use a região para mapear a cor dos pontos. 4. Aumente o tamanho dos pontos (size = 2) 5. Associe o tamanho dos pontos ao HDI.Rank 9.12 Recursos adicionais ggplot2: - Mailing list: [http://groups.google.com/group/ggplot2](http://groups.google.com/group/ggplot2) - Wiki: [https://github.com/hadley/ggplot2/wiki](https://github.com/hadley/ggplot2/wiki) - Website: [http://had.co.nz/ggplot2/](http://had.co.nz/ggplot2/) - StackOverflow: [http://stackoverflow.com/questions/tagged/ggplot](http://stackoverflow.com/questions/tagged/ggplot) References "],
["manipulando-dados.html", "Unidade 10 Manipulando Dados 10.1 Tibbles 10.2 Dados 10.3 Funções básicas 10.4 Filtrando registros (linhas) 10.5 Organizando registros (linhas) 10.6 Selecionando variáveis (colunas) 10.7 Criando novas variáveis 10.8 Sumarizando dados grupados 10.9 Pipes 10.10 Dados ausentes 10.11 Outros exemplos de funções agregadoras", " Unidade 10 Manipulando Dados Neste capítulo vou adotar uma abordagem diferente do que fizemos quando introduzimos Gráficos em R. Na apresentação dos gráficos iniciamos pela biblioteca base e depois conhecemos o pacote ggplot2, que considero um muito mais que um aprimoramento para aqueles que desejam gráficos mais refinados, mas sim um pacote com todo um suporte conceitual de como criar visualizações dos seus dados de uma maneira sistemática e mais fácil. Aqui vou iniciar utilizando pacotes que tornam a manipulação de dados mais fácil de ser compreentendida e implementada, pacotes que fazem parte de um grupo chamado de tidyverse. Tidyverse (Wickham 2017) é uma família de pacotes que compartilham uma mesma filosofia de uso e design para trabalharem juntos de forma harmônica. David Robinson no seu Blog Variance Explained descreve por que prefere iniciar seus estudantes com tidyverse, o que acaba também corroborando com o fato de que a maioria do material de R disponibilizado na internet já usa essa filosofia. Many teachers suggest I’m overestimating their students: “No, see, my students are beginners…”. If I push the point, they might insist I’m not understanding just how much of a beginner these students are, and emphasize they’re looking to keep it simple and teach the basics, and that that students can get to the advanced methods later…. My claim is that this is precisely backwards. ggplot2 is easier to teach beginners, not harder, and makes constructing plots simpler, not more complicated. — David Robinson - Data Scientist. E ele está citando ggplot2 porque esse pacote também é parte da família tidyverse. Um exemplo de como alguns dos pacotes de tidyverse podem ser combinados no workflow de análise de dados de pode ser visualizado na figura 10.1. Figura 10.1: Data Analysis Workflow recriado com alguns pacotes de tidyverse (Fonte:(Gergana et al. 2017)). Nosso foco neste capítulo será abordar a manipulação de dados usando o pacote Dplyr(Wickham et al. 2017). 10.1 Tibbles Ao invés de trabalharmos com data frames usaremos aqui uma estrutura chamada tibble. Tibble nada mais é do que um data frames melhorado, mais flexível. Mas melhorado em termos de que? Bom, a definição formal da linguagem R aconteceu já faz um bom tempo, e a concepção de data frame elaborada naquela época, apesar de contínuar a atender os requisitos básicos para manipulação de tabelas, não é totalmente compatível com as inovações descobertas ao longo desses anos. Mudar um tipo básico como data frame poderia causar um caos na compatibilidade com o códigi já existente. Assim, algumas inovações foram inseridas em um tipo especial chamado tiblle, permitindo que os dados possam ser manipulados com mais flexibilidade sem quebrar a compatibilidade com o tipo data frames. Tibbles são usados principalmente nos pacotes da família tydeverse, mas normalmente citados como se fossem data frames. Se vc deseja conhecer mais um pouco sobre tibbles, consulte livro R for Data Science de Garrett Grolemund e Hadley Wickham (Grolemund and Wickham 2016). Ou acesse vignette(“tibble”) no site CRAN-R Uma das muitas vantagens de se usar tibbles ao se trabalhar com grandes bancos de dados, é que ao imprimir seus dados, apenas as serão imprssas as 10 primeiras linhas e as colunas que couberem no console. Normalmente o tipo tibble é carregado junto com os pacotes família tydeverse, por exemplo o Dplyr. ## ## Attaching package: &#39;dplyr&#39; ## The following objects are masked from &#39;package:stats&#39;: ## ## filter, lag ## The following objects are masked from &#39;package:base&#39;: ## ## intersect, setdiff, setequal, union 10.1.1 Usando tibbles Qualquer data frame pode ser convertido em tibble usando a função as_tibble(). as_tibble(iris) ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fctr&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5.0 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # ... with 140 more rows 10.2 Dados Os exemplos a seguir foram baseados nas vignettes de dplyr, que utiliza os dados nycflights13::flights que contém todos os vôos que partiram da cidade de Nova York(EUA) em 2013, disponibilizados pelo US Bureau of Transportation Statistics, e armazenados no pacote nycflights13. Na verdade o pacote nycflights13 contém um extenso banco relacional que também pode ser usados para entender como manipular dados distribuídos em tabelas distintas em um banco relacional. (Consulte “Relacional Data” em Grolemund and Wickham (2016) para maiores informações). 10.2.1 Carregando os dados Instale o pacote antes de carregar e observe que os dados flights já são armazenados como o tipo tibble e por isso são impressos de forma reduzida. library(nycflights13) dim(flights) ## [1] 336776 19 flights ## # A tibble: 336,776 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # ... with 336,766 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Para checar a estrutura dos dados use glimpse(), ou help(flights) para uma descrição das variáveis. glimpse(flights) ## Observations: 336,776 ## Variables: 19 ## $ year &lt;int&gt; 2013, 2013, 2013, 2013, 2013, 2013, 2013, 2013,... ## $ month &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,... ## $ day &lt;int&gt; 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,... ## $ dep_time &lt;int&gt; 517, 533, 542, 544, 554, 554, 555, 557, 557, 55... ## $ sched_dep_time &lt;int&gt; 515, 529, 540, 545, 600, 558, 600, 600, 600, 60... ## $ dep_delay &lt;dbl&gt; 2, 4, 2, -1, -6, -4, -5, -3, -3, -2, -2, -2, -2... ## $ arr_time &lt;int&gt; 830, 850, 923, 1004, 812, 740, 913, 709, 838, 7... ## $ sched_arr_time &lt;int&gt; 819, 830, 850, 1022, 837, 728, 854, 723, 846, 7... ## $ arr_delay &lt;dbl&gt; 11, 20, 33, -18, -25, 12, 19, -14, -8, 8, -2, -... ## $ carrier &lt;chr&gt; &quot;UA&quot;, &quot;UA&quot;, &quot;AA&quot;, &quot;B6&quot;, &quot;DL&quot;, &quot;UA&quot;, &quot;B6&quot;, &quot;EV&quot;,... ## $ flight &lt;int&gt; 1545, 1714, 1141, 725, 461, 1696, 507, 5708, 79... ## $ tailnum &lt;chr&gt; &quot;N14228&quot;, &quot;N24211&quot;, &quot;N619AA&quot;, &quot;N804JB&quot;, &quot;N668DN... ## $ origin &lt;chr&gt; &quot;EWR&quot;, &quot;LGA&quot;, &quot;JFK&quot;, &quot;JFK&quot;, &quot;LGA&quot;, &quot;EWR&quot;, &quot;EWR&quot;... ## $ dest &lt;chr&gt; &quot;IAH&quot;, &quot;IAH&quot;, &quot;MIA&quot;, &quot;BQN&quot;, &quot;ATL&quot;, &quot;ORD&quot;, &quot;FLL&quot;... ## $ air_time &lt;dbl&gt; 227, 227, 160, 183, 116, 150, 158, 53, 140, 138... ## $ distance &lt;dbl&gt; 1400, 1416, 1089, 1576, 762, 719, 1065, 229, 94... ## $ hour &lt;dbl&gt; 5, 5, 5, 5, 6, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 5,... ## $ minute &lt;dbl&gt; 15, 29, 40, 45, 0, 58, 0, 0, 0, 0, 0, 0, 0, 0, ... ## $ time_hour &lt;dttm&gt; 2013-01-01 05:00:00, 2013-01-01 05:00:00, 2013... #help(flights) Vale frisar que os dados consideram que os três aeroportos de New York (JFK, LGA e EWR) funcionam como um hub, sendo os voos planejados para retornar de onde partiram. Figura 10.2: Voos chegam no hub e retornam para o ponto de partida 10.3 Funções básicas Funcões básicas disponibilizadas pelo pacote Dplyr para manipulação de dados: filter() para selecionar registros específicos . arrange() para ordenar os registros segundo uma regra definida. select() e rename() para selecionar variáveis baseado nos seus nomes. mutate() e transmute() para adicionar novas variáveis em função das já existentes. summarise() para condensar multiplos valores. sample_n() e sample_frac() para a abtenção de amostras aleatórias. 10.4 Filtrando registros (linhas) O comando filter() permite que registros (linhas da sua tabela) possam ser selecionados de forma mais simples e prática. Como padrão em tidyverse, o argumento define o conjunto de dados. Exemplos filter(starwars, species == &quot;Human&quot;) filter(starwars, mass &gt; 1000) # Múltiplos critérios filter(starwars, hair_color == &quot;none&quot; &amp; eye_color == &quot;black&quot;) filter(starwars, hair_color == &quot;none&quot; | eye_color == &quot;black&quot;) # Múltiplos argumentos são equivalentes a &quot;and/e&quot; filter(starwars, hair_color == &quot;none&quot;, eye_color == &quot;black&quot;) O filtro é usado de acordo com os operadores booleanos abaixo: Figura 10.3: Operadores booleanos usados em filter(). x representa o círculo esquerdo e y o círculo direito, e a área sombreada a selação. (Fonte:(Grolemund and Wickham 2016)). Por exemplo, para selecionar todos o voos do dia 01 de Janeiro: filter(flights, month == 1, day == 1) ## # A tibble: 842 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # ... with 832 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; Exercícios: Crie uma variável contendo todos os voos que partiram nos meses de novembro e dezembro: Solução nov_dez &lt;- filter(flights, month == 11 | month == 12) #ou nov_dez &lt;- filter(flights, month %in% c(11, 12)) Encontre os voos que não atrasaram (na partida ou chegada) por mais de duas horas: Solução filter(flights, arr_delay &lt;= 120, dep_delay &lt;= 120) ## # A tibble: 316,050 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # ... with 316,040 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; #ou filter(flights, !(arr_delay &gt; 120 | dep_delay &gt; 120)) ## # A tibble: 316,050 x 19 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # ... with 316,040 more rows, and 12 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt; 10.4.1 Exercícios Encontre os voos que: possuem um atraso de chegada de duas ou mais horas Voaram para a cidade de Houston (IAH ou HOU) Foram operados pelas companhias United, American ou Delta Ailines Partiram no verão dos EUA (julho, agosto e setembro) Chegaram mais de duas horas atrasados, mas não decolaram atrasados. Partiram entre meia noite e as 06:00 (inclusive) Outra opção para usar com o comando de filtro é a função between(). Você poderia usá-lo para simplificar o código necessário para responder às queries anteriores? Quantos voos possuem valores ausentes em dep_time (NA)? Que outras variáveis estão ausentes? O que podem representar essas linhas com valores ausentes? 10.5 Organizando registros (linhas) O comando arrange() é usado para organizar as linhas, que funciona de maneira similar à operação filtragem, exceto que aqui será alterada a ordem com que os registros (linhas) serão apresentados. O default é usar a primeira coluna informada para a ordenação crescente, e as seguintes são usadas como uma chave adicional. . Exemplo: arrange(flights, year, month, day) No caso da ordenação ser decrescente, basta usar a função desc(): arrange(flights, year, month, desc(day)) Vale a pena frisar que os valores ausentes sempre vão aparecer no final: df &lt;- tibble(x = c(5, 2, NA)) arrange(df, x) ## # A tibble: 3 x 1 ## x ## &lt;dbl&gt; ## 1 2 ## 2 5 ## 3 NA arrange(df, desc(x)) ## # A tibble: 3 x 1 ## x ## &lt;dbl&gt; ## 1 5 ## 2 2 ## 3 NA 10.5.1 Exercícios Como aplicar arrange() de modo que os valores ausentes apareçam no início? (Dica: use is.na()). Classifique os voos por ordem de atraso. E dentre esses os que partem mais cedo. 10.6 Selecionando variáveis (colunas) O comando select() pode ser usado de diversas formas para selecionar apenas aquelas variáveis (colunas) interessantes para uma dada análise. Nesse caso, o novo conjunto de dados só conterá as colunas selecionadas. Exemplos: select(flights, year, month, day) select(flights, year:day) select(flights, -(year:day)) 10.6.1 Funções de apoio em select() - “-” exclua da selação - “:” Selecione a faixa (range) - `contains()` Seleciona colunas que contenham no nome os caracteres(strings) definidos - `starts_with()` Seleciona colunas que cujo nome iniciem com os caracteres(strings) definidos - `ends_with()` Seleciona colunas que cujo nome sejam finalizados com os caracteres(strings) definidos - `everything()` Seleciona todas as colunas - `matches()` Seleciona colunas nas quais o nome atende a uma expressão - `num_range()` Seleciona colunas nomeadas em uma sequência. [e.g. num_range(&quot;x&quot;, 1:5) para x1, x2, x3, x4, x5] - `one_of()` Seleciona colunas cujo nome pertença a um grupo Use o help() para explorar essas funções! Exemplos: Seleciona todas as colunas exceto tailnum: select(flights,-tailnum) Seleciona todas as colunas cujo nome contenha “time”: select(flights,contains(&quot;time&quot;)) ## # A tibble: 336,776 x 6 ## dep_time sched_dep_time arr_time sched_arr_time air_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 517 515 830 819 227 ## 2 533 529 850 830 227 ## 3 542 540 923 850 160 ## 4 544 545 1004 1022 183 ## 5 554 600 812 837 116 ## 6 554 558 740 728 150 ## 7 555 600 913 854 158 ## 8 557 600 709 723 53 ## 9 557 600 838 846 140 ## 10 558 600 753 745 138 ## # ... with 336,766 more rows, and 1 more variables: time_hour &lt;dttm&gt; Comunas também podem ser renomeadas com o select() select(flights,year,carrier,destination=dest) ## # A tibble: 336,776 x 3 ## year carrier destination ## &lt;int&gt; &lt;chr&gt; &lt;chr&gt; ## 1 2013 UA IAH ## 2 2013 UA IAH ## 3 2013 AA MIA ## 4 2013 B6 BQN ## 5 2013 DL ATL ## 6 2013 UA ORD ## 7 2013 B6 FLL ## 8 2013 EV IAD ## 9 2013 B6 MCO ## 10 2013 AA ORD ## # ... with 336,766 more rows A função everything() pode ser usada em conjunção com select() para reodenar as colunas. select(flights, time_hour, air_time, everything()) ## # A tibble: 336,776 x 19 ## time_hour air_time year month day dep_time sched_dep_time ## &lt;dttm&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 2013-01-01 05:00:00 227 2013 1 1 517 515 ## 2 2013-01-01 05:00:00 227 2013 1 1 533 529 ## 3 2013-01-01 05:00:00 160 2013 1 1 542 540 ## 4 2013-01-01 05:00:00 183 2013 1 1 544 545 ## 5 2013-01-01 06:00:00 116 2013 1 1 554 600 ## 6 2013-01-01 05:00:00 150 2013 1 1 554 558 ## 7 2013-01-01 06:00:00 158 2013 1 1 555 600 ## 8 2013-01-01 06:00:00 53 2013 1 1 557 600 ## 9 2013-01-01 06:00:00 140 2013 1 1 557 600 ## 10 2013-01-01 06:00:00 138 2013 1 1 558 600 ## # ... with 336,766 more rows, and 12 more variables: dep_delay &lt;dbl&gt;, ## # arr_time &lt;int&gt;, sched_arr_time &lt;int&gt;, arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, ## # flight &lt;int&gt;, tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, distance &lt;dbl&gt;, ## # hour &lt;dbl&gt;, minute &lt;dbl&gt; 10.6.2 Exercício Como usar a função one_of(). Teste com: vars &lt;- c(&quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;dep_delay&quot;, &quot;arr_delay&quot;) 10.7 Criando novas variáveis O comando mutate() é um dos comandos mais utéis quando é necessário criar novas variáveis em função das já existentes. As novas variáveis(colunas) serão adicionadas no final. Exemplo: flights_sml &lt;- select(flights, year:day, ends_with(&quot;delay&quot;), distance, air_time ) mutate(flights_sml, gain = arr_delay - dep_delay, speed = distance / air_time * 60 ) ## # A tibble: 336,776 x 9 ## year month day dep_delay arr_delay distance air_time gain speed ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2013 1 1 2 11 1400 227 9 370.0441 ## 2 2013 1 1 4 20 1416 227 16 374.2731 ## 3 2013 1 1 2 33 1089 160 31 408.3750 ## 4 2013 1 1 -1 -18 1576 183 -17 516.7213 ## 5 2013 1 1 -6 -25 762 116 -19 394.1379 ## 6 2013 1 1 -4 12 719 150 16 287.6000 ## 7 2013 1 1 -5 19 1065 158 24 404.4304 ## 8 2013 1 1 -3 -14 229 53 -11 259.2453 ## 9 2013 1 1 -3 -8 944 140 -5 404.5714 ## 10 2013 1 1 -2 8 733 138 10 318.6957 ## # ... with 336,766 more rows E as colunas recem criadas podem já ser usadas em novas expressões: mutate(flights, gain = arr_delay - dep_delay, hours = air_time / 60, gain_per_hour = gain / hours ) ## # A tibble: 336,776 x 22 ## year month day dep_time sched_dep_time dep_delay arr_time ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; ## 1 2013 1 1 517 515 2 830 ## 2 2013 1 1 533 529 4 850 ## 3 2013 1 1 542 540 2 923 ## 4 2013 1 1 544 545 -1 1004 ## 5 2013 1 1 554 600 -6 812 ## 6 2013 1 1 554 558 -4 740 ## 7 2013 1 1 555 600 -5 913 ## 8 2013 1 1 557 600 -3 709 ## 9 2013 1 1 557 600 -3 838 ## 10 2013 1 1 558 600 -2 753 ## # ... with 336,766 more rows, and 15 more variables: sched_arr_time &lt;int&gt;, ## # arr_delay &lt;dbl&gt;, carrier &lt;chr&gt;, flight &lt;int&gt;, tailnum &lt;chr&gt;, ## # origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, ## # minute &lt;dbl&gt;, time_hour &lt;dttm&gt;, gain &lt;dbl&gt;, hours &lt;dbl&gt;, ## # gain_per_hour &lt;dbl&gt; E se o interesse é manter apenas as novas colunas, use transmute(): transmute(flights, gain = arr_delay - dep_delay, hours = air_time / 60, gain_per_hour = gain / hours ) ## # A tibble: 336,776 x 3 ## gain hours gain_per_hour ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 9 3.7833333 2.378855 ## 2 16 3.7833333 4.229075 ## 3 31 2.6666667 11.625000 ## 4 -17 3.0500000 -5.573770 ## 5 -19 1.9333333 -9.827586 ## 6 16 2.5000000 6.400000 ## 7 24 2.6333333 9.113924 ## 8 -11 0.8833333 -12.452830 ## 9 -5 2.3333333 -2.142857 ## 10 10 2.3000000 4.347826 ## # ... with 336,766 more rows A função mutate() aceita uma serie de operações para a criação de novas variáveis, o que é extremamente útil na contrução de modelos estísticos de previsão, ou mais específivamente no contexto chamado de feature engineering. Além dos operadores aritméticos &quot; +, - , *, /, ^ &quot; (e.g. air_time/60), expressões com operadores lógicos e modulares %/% (divisão inteira) e %% (resto) podem ser utilizados (e.g. x == y * (x %/% y) + (x %% y) ). Funções agregadoras, entre outras, também podem ser empregadas (e.g. x/sum(x), y - mean(y) ). 10.7.1 Exercícios: Compare air_time com (arr_time - dep_time). O resultado indica algum padrão? O que aconteceu com o resultado? Como corrigir? Compare dep_time, sched_dep_time, and dep_delay. Qual é a relação esperada entre essas variáveis? 10.8 Sumarizando dados grupados Trabalhar sobre dados grupados é uma das grande facilidades proprorcionadas pelo pacote Dplyr. Essa funcionalidade é disponibilizada pela função sumarise(), usada em conjunto com a função group_by(). Por exemplo, para calcular o atraso médio por dia: by_day &lt;- group_by(flights, year, month, day) summarise(by_day, delay = mean(dep_delay, na.rm = TRUE)) #removendo os dados ausentes ## # A tibble: 365 x 4 ## # Groups: year, month [?] ## year month day delay ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 11.548926 ## 2 2013 1 2 13.858824 ## 3 2013 1 3 10.987832 ## 4 2013 1 4 8.951595 ## 5 2013 1 5 5.732218 ## 6 2013 1 6 7.148014 ## 7 2013 1 7 5.417204 ## 8 2013 1 8 2.553073 ## 9 2013 1 9 2.276477 ## 10 2013 1 10 2.844995 ## # ... with 355 more rows Antes de continuar, torna-se interessante introduzir um novo conceito, pipes. O uso de pipes, como veremos a seguir, pode tornar códigos complexos mais fácil de serem constrídos e lidos. 10.9 Pipes Imagine que precisamos codificar o seguinte texto: Batatinha quando nasce, esparrama pelo chão. usando as seguintes funções: - nasce(objeto) #&quot;para criação do objeto&quot; - esparrama( objeto , lugar) Ficaríamos com algo do tipo: batatinha &lt;- nasce(&quot;batata&quot;) esparrama(batatinha, &quot;chão&quot;) Se quisermos montar uma cadeia de comandos poderíamos fazer: esparrama( nasce(&quot;batata&quot;), &quot;chão&quot; ) Note que os comandos foram aninhados de de dentro para fora, de forma que a função mais interna é executada e seu resultado torna-se argumento para a função externa. Apesar deste processo não ser muito intuitivo, essa é a forma comumente usado em liguagens de programação. Não seria melhor se pudéssemos escrever o código na mesma sequência da frase. É exatamente isso que o uso de pipes (%&gt;%) proporciona: nasce(&quot;batata&quot;) %&gt;% esparrama(&quot;chão&quot;) Ao ler o código, Grolemund and Wickham (2016) sugere que %&gt;% deve ser pronunciado como “então”. Eu particularmente prefiro “pipe” mesmo :) Internamente, x %&gt;% f(y) se transforma em f(x, y), e x %&gt;% f(y) %&gt;% g(z) gera g(f(x, y), z). Essa simples operação melhora sobremaneira a redigibilidade. Usando os dados flights (exemplo em Grolemund and Wickham (2016)), poderíamos usar a função de summarise() para explorar a relação entre distância e atraso médio em função do destino, com dplyr, da seguinte forma: by_dest &lt;- group_by(flights, dest) delay &lt;- summarise(by_dest, count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE) ) delay &lt;- filter(delay, count &gt; 20, dest != &quot;HNL&quot;) Usando um gráfico de pontos para investigar a relação, temos: ggplot(data = delay, mapping = aes(x = dist, y = delay)) + geom_point(aes(size = count), alpha = 1/3) + geom_smooth(se = FALSE) ## `geom_smooth()` using method = &#39;loess&#39; Podemos observar que os atrasos aumentam até a distância de ~750 milhas e depois decrescem. Provavelmente, voos mais longos permitem que os atrasos possam ser compensados no ar! Os passos usados para preparar os dados foram: 1. `group_by()` para grupar os dados por destino. 2. `summarise()` para computar a distância, delay médio, e número de voos. 3. `filter()` para remover pontos expúrios(ruídos) e o aeroporto de Honolulu, cuja distância é quase o dobro da segunda maior. Ao usarmos pipes o código passa a ser escrito como abaixo e não há necessidade de um repositório intermediário de dados: delays &lt;- flights %&gt;% group_by(dest) %&gt;% summarise( count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE) ) %&gt;% filter(count &gt; 20, dest != &quot;HNL&quot;) Ou mesmo, linkando o código com ggplot2: flights %&gt;% group_by(dest) %&gt;% summarise( count = n(), dist = mean(distance, na.rm = TRUE), delay = mean(arr_delay, na.rm = TRUE) ) %&gt;% filter(count &gt; 20, dest != &quot;HNL&quot;) %&gt;% ggplot(mapping = aes(x = dist, y = delay)) + geom_point(aes(size = count), alpha = 1/3) + geom_smooth(se = FALSE) 10.10 Dados ausentes O que aconteceria acima se os dados ausente não fossem removidos nas funções de agrupamento (na.rm=TRUE)? Teste o comando: flights %&gt;% group_by(year, month, day) %&gt;% summarise(mean = mean(dep_delay)) Solução # Em funções agregadoras, se os dados de entrada possuem dados ausentes, a saída será &quot;NA&quot;. Por isso considere sempre a possibilidade de definir &quot;rm.na=TRE&quot; flights %&gt;% group_by(year, month, day) %&gt;% summarise(mean = mean(dep_delay)) ## # A tibble: 365 x 4 ## # Groups: year, month [?] ## year month day mean ## &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 2013 1 1 NA ## 2 2013 1 2 NA ## 3 2013 1 3 NA ## 4 2013 1 4 NA ## 5 2013 1 5 NA ## 6 2013 1 6 NA ## 7 2013 1 7 NA ## 8 2013 1 8 NA ## 9 2013 1 9 NA ## 10 2013 1 10 NA ## # ... with 355 more rows Podemos também usar os dados ausentes para identificar os voos cancelados. Assim, esses voos seriam excluídos da nossa análise. Considere então que os voos não cancelados são aqueles que possuem de atraso (delay) na chegada e na saída. E para os voos cancelados um dos dados está ausente. not_cancelled &lt;- flights %&gt;% filter(!is.na(dep_delay), !is.na(arr_delay)) 10.10.1 Contando os NA Uma boa prática é sempre investigar os número de observações(n()) ou o número de dados ausentes (sum(!is.na(x)))quando estamos usando funções agregadoras, pois as conclusões podem ser influenciadas por uma parcela pequena dos dados. Considere novamente os dados referentes ao atraso dos voos não cancelados. Vamos considerar o atraso médio por aeronaves (identificadas por tailnum). A função geom_freqpoly() plota a distribuição dos atrasos médios (delays$delay) usando uma linha. delays &lt;- not_cancelled %&gt;% group_by(tailnum) %&gt;% summarise( delay = mean(arr_delay) ) ggplot(data = delays, mapping = aes(x = delay)) + geom_freqpoly(binwidth = 10) (Teste geom_histogram() e veja a diferença) Solução ggplot(data = delays, mapping = aes(x = delay)) + geom_histogram(binwidth = 10) Podemos notar que existem atrasos médios de até 5 horas em alguns voos! Mas investigando melhor podemos ver como é a relação entre os atrasos médios (delay) e o número de voos. delays &lt;- not_cancelled %&gt;% group_by(tailnum) %&gt;% summarise( delay = mean(arr_delay), n = n() ) ggplot(data = delays, mapping = aes(x = n, y = delay)) + geom_point(alpha = 1/10) Note que há grandes variações quando o número de voos é menor. O que pode ser explicado pelo fato de que nesses casos a média pode estar sendo altamente influenciada por outliers, e a amostra ainda não possui tamanho suficiente para estabilizar essa variação. (A aplicaçào de estatística bayesiana pode amenizar esse efeito, mas é assunto para outro tópico). Vamos repetir o gráfico acima considerando somente os atrasos onde a média considerou mais de 25 voos. Solução delays %&gt;% filter(n &gt; 25) %&gt;% ggplot( mapping = aes(x = n, y = delay)) + geom_point(alpha = 1/10) 10.11 Outros exemplos de funções agregadoras A média é uma medida (mean()) bastante usada, mas medidas como a mediada (median(x)) pode dimunuir os efeitos dos outliers. Subsetting significa usar um filtro nos valores das colunas e pode ser aplicado com summarise(). not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarise( avg_delay1 = mean(arr_delay), # Considere somente os atrasos (positivos) avg_delay2 = mean(arr_delay[arr_delay &gt; 0]) ) Medidas de dispersão como sd(), IRQ() e mad() (desvio absoluto em relação a média), sendo os dois últimos mais robustos em relação aos outliers. # Algumas distância voadas variam mais dependendo do destino? not_cancelled %&gt;% group_by(dest) %&gt;% summarise(distance_sd = sd(distance)) %&gt;% arrange(desc(distance_sd)) Medidas de posição: first(x), nth(x, 2), last(x). Indicadas para retornor um dado elemento de um grupamento. Se a posição indicada não existir devolve um valor default (i.e. Ao tentar recuperar o terceiro elemento de uma lista de dois elementos). not_cancelled %&gt;% group_by(year, month, day) %&gt;% summarise( first_dep = first(dep_time), last_dep = last(dep_time) ) Ou até mesmo combinar summarize() com filter() popular_dests &lt;- flights %&gt;% group_by(dest) %&gt;% filter(n() &gt; 365) # mais de um voo por dia popular_dests O RStudio disponibiliza uma folha de resumo para pacotes Dplyr e Tidyr (Data Wrangling Cheatsheet - RStudio). Para conhecer mais consulte o livro R for Data Science de Garrett Grolemund e Hadley Wickham (Grolemund and Wickham 2016). References "],
["references.html", "References", " References "]
]
